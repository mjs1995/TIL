# 도커 관리 
- 도커 컴포즈 : 다수의 컨테이너 운용 도구, 도커 컴포즈
  - 도커는 컨테이너 기반의 오픈소스 가상화 플랫폼
  - 복잡한 리눅스 애플리케이션을 컨테이너로 묶어서 실행할 수 있음
  - 개발, 테스트, 서비스 환경을 하나로 통일하여 효율적으로 관리할 수 있음
  - 컨테이너(이미지)를 전 세계 사람들과 공유
  - Docker compose 명령은 여러 개의 컨테이너 옵션과 환경을 정의한 파일을 읽어 컨테이너를 순차적으로 실행시킴
  - 도커 컴포즈 설정 파일(docker-compose.yml)은 run 명령어 옵션을 그대로 사용할 수 있으며, 각 컨테이너의 의존성, 네트 워크, 볼륨, 컨테이너 수 등을 유동적으로 조절할 수 있음
  - 도커 컴포즈 기본 수행 절차
    - Dockerfile 정의 : 앱 환경 설정
    - docker-compose.yml 설정 : 앱과 같이 수행 될 서비스 설정
    - docker-compose up을 통한 전체 앱 실행
  - 도커 컴포즈 yaml 포맷
    - ```yaml
      version: '3'
      services:
        mdb:
          image:mariadb:latest
          environment: MYSQL_ROOT_PASSWORD:1234
        web:
          build:./dockerfile
          image:apache_df:web
          ports:
            - "80:80"
          links:
            - mdb:mdb
      ```
      - version : docker-compose.yml 내용을 해석하기 위한 문법 버전 -3 버전은 안전 버전
      - Services: 생성될 컨테이너의 정보를 담고 있음. Services 바로 아래에 서비스명을 기술할 수 있으며 위에 기술된 mdb, web이 서비스명이 됨
      - Echo : services 아래의 echo는 컨테이너 이름임. 즉, echo는 하나의 컨테이너
      - image/ports : 도커 이미지/포트포워딩
    - 컨테이너 실행 : docker-compose up
    - 컨테이너 종료 : docker-compose down
  - 도커 컴포즈로 할 수 있는 것
    - 단일 호스트 상, 다수의 독립 환경 운용
    - 컨테이너 볼륨의 보존
    - 변경된 컨테이너의 재생성
    - 환경 간 변수 및 구성 이동 
- 도커 
  - 도커를 사용해야 하는 이유
    - 코드를 신속히 전달 및 이동 가능
    - 애플리케이션 운영의 표준화 가능
    - 소스 사용률을 높여 비용 절감
    - 어디서나 안정적으로 실행할 수 있는 단일 객체 확보
    - 간단한 구문을 사용해 완벽하게 제어
    - 도구 및 상용 애플리케이션의 에코시스템이 강력
  - 도커를 사용하면
    - 마이크로 서비스 : 도커 컨테이너를 통해 표준화된 코드 배포를 활용하여 분산 애플리케이션 아키텍처를 구축하고 확장함
    - 지속적인 통합 및 제공 : 환경을 표준화하고 언어 스택 및 버전 간의 충돌을 제거함으로써 애플리케이션을 더욱 빠르게 제공함
    - 서비스로서의 컨테이너 : 안전한 IT 관리형 인프라의 콘텐츠로 분산 애플리케이션을 구축 및 제공함
    - 데이터 처리 : 빅 데이터 처리를 서비스로 제공, 데이터 및 분석 패키지를 기술자가 아닌 사용자도 실행할 수 있는 이동식 컨테이너로 패키징
  - 도커 아키텍처
    - ![image](https://github.com/mjs1995/Certified-AWS/assets/47103479/59ec11aa-ba04-4570-954e-76a81e7c9273)
      - https://www.leafcats.com/146
    - Client : 도커 컨테이너를 관리하고 실행하기 위해서 Daemon과 상호작용하는 Binary 파일
    - Registry : 도커 이미지가 저장되어 있는 장소. 대표적으로 도커 허브가 있음. Registry는 Public Registry와 Private Registry가 있음
    - Daemon : Host에 설치되어 도커 컨테이너를 관리하는 데몬 프로세스. Client와 상호 작용함
    - Image : 도커 데몬을 통해 컨테이너로 실행 가능하도록 필요한 프로그램, 라이브러리, 소스 등이 설치된 파일
    - Container : Image를 실행한 상태 
  - 도커 이미지
    - 컨테이너 실행에 필요한 파일과 설정값 등을 포함하고 있는 것으로 상태값을 가지지 않고 변하지 않음
    - 컨테이너는 이미지를 실행한 상태라고 볼 수 있고 추가되거나 변하는 값은 컨테이너에 저장됨
- 도커 스웜 : 오케스트레이션 도구
  - 컨테이너 오케스트레이션 도구, 도커 스웜
    - 도커 컨테이너의 개수가 꾸준히 늘어나면 필요한 자원도 지속해서 늘어나게 됨
    - 서버가 몇십 몇 백대로 늘어나면, 많은 서버에 일일이 접근하여 명령어를 실행하고 컨테이너 올리고 반복하면 많은 시간이 소요됨 
    - 많은 서버와 컨테이너를 효율적으로 관리하기 위해 컨테이너 오케스트레이션 툴이 나오게 됨(도커 스웜, 쿠버네티스, 아파치 메소스)
  - 오케스트레이션 툴의 기능
    - 컨테이너 자동배치 및 복제
    - 컨테이너 그룹에 대한 로드밸런싱
    - 컨테이너 장애 복구
    - 클러스터 외부에 서비스 노출
    - 컨테이너 추가 또는 제거를 이용한 확장 및 축소
    - 스케줄링, 클러스터링
    - 서비스 디스커버리
    - 로깅, 모니터링
  - 도커 스웜(docker SWARM)
    - 컨테이너 오케스트레이션 도구 중의 하나로, 여러 대의 Docker 호스트를 마치 하나인 것처럼 만들어주는 오케스트레이션 도구
    - 용어
      - 스웜 : 스웜 클러스터 자체도 스웜이라 함
      - 노드 : 스웜 클러스터에 속한 도커 서버의 단위. 보통 한 서버에 하나의 도커 데몬만 실행하므로 서버가 곧 노드라고 이해하면 됨
      - 매니저 노드 : 스웜 클러스터 상태를 관리하는 노드. 매니저 노드는 곧 워커 노드가 될 수 있고 스웜 명령어는 매니저 노드에서만 실행됨 
      - 워커 노드 : 매니저 노드의 명령을 받아 컨테이너를 생성하고 상태를 체커하는 노드
      - 서비스 : 기본적인 배포 단위. 하나의 서비스는 하나의 이미지를 기반으로 생성
      - 테스크 : 컨테이너 배포 단위. 하나의 서비스는 여러 개의 테스크를 실행할 수 있고 각각의 테스크가 컨테이너를 관리 
    - 아키텍처
      - ![image](https://github.com/mjs1995/TIL/assets/47103479/a3aeb220-b012-42a8-a939-064204006f39)
        - https://medium.com/@ITsolutions/containers-102-continuing-the-journey-from-os-virtualization-to-workload-virtualization-54fe5576969d
      - Nodes: 노드는 스웜에 참여하는 도커 엔진의 Instance 들
      - Manager Node
        - Application을 스웜에 배포하기 위해서는 먼저 매니저 노드에 서비스라는 이름의 정의서를 전달해야 함. 그 후, 매니저 노드는 워커 노드들에 테스크라고 불리는 작업 단위를 전달하여, 서비스를 정상적으로 생성함
      - Worker Node
        - 워커 노드는 매니저 노드로부터 테스크를 수신 받고 컨테이너를 실행함. 즉 스케줄에 대한 결정을 내리거나 스웜 모드의 HTTP API를 제공하지 않고, 오로지 컨테이너를 실행시키는 것이 Docker Instance의 유일한 목적임 
    - 구성 요소
      - 매니저 노드
        - Scheduler : 서비스를 테스크로 분할. 각 워커 노드에 배치 계획
        - Service Discovery : 컨테이너의 실행 위치와 상태 제공, 자체 DNS 운영
        - Docker Daemon : Raft 알고리즘 사용. 매니저 노드 고가용성 제공
        - Docker API over HTTP : HTTP 프르토콜을 이용한 내부 통신
      - 워커 노드
        - Docker Daemon : 매니저의 테스크를 받아 컨테이너를 생성 및 상태 체크
      - Registry
        - Docker Registry : Dockerfile 및 컨테이너 이미지 제공 
    - 기능
      - 컨테이너 자동 배치/ 복제
      - 컨테이너 그룹 로드 밸런싱
      - 컨테이너 장애 복구
      - 클러스터 외부 서비스 노출
      - 컨테이너 추가/제거/확장/축소
      - 컨테이너 서비스 간 I/F 통한 연결
        - 여러 개의 Docker 호스트를 함께 클러스터링하여 단일 가상 Docker 호스트 생성
        - Host OS에 Agent만 설치하려면 간단하게 작동되고 설정이 쉽고 Agent를 외부에 설치하지 않음
        - Docker 명령어와 Compose를 그대로 사용 가능 
    - 스웜 클래식과 스웜 모드의 구조적 차이
      - |구분|스웜 클래식|스웜 모드|
        |:---:|:---:|:---:|
        |구성도|여러 대의 서버를 하나의 지점에서 사용하도록 단일 접근점 제공에 초점|마이크로서비스 아키텍처의 컨테이너를 위한 클러스터링 기능에 초점|
        |분산 코디네이터|분산 코디네이터가 별도로 구동|내부에서 분산 코디네이터를 구동|
        |에이전트 컨테이너|클러스터 구성을 위한 별도 에이전트 필요|클러스터 구성을 위한 에이전트가 내부에 존재|
        |장애 지원|단일 접근점 제공에 따라 로드밸런싱 없음|서비스 장애 대비 로드밸런싱 기능 제공|
        |대규모 클러스터|스웜 모드에 비해 대규모 클러스터 서비스 지원이 어려움|대규모 클러스터 서비스에 강점|
        |구축 용이성|스웜 모드에 비해 구성이 어려움|스웜 클래식보다 빠른 구성|
    - 오케스트레이션 툴 비교
      - |구분|Google Kubernetes|Docker Swarm|Apache Mesos|
        |:---:|:---:|:---:|:---:|
        |특징 요약|다양한 테스트를 만족하는 안정적인 솔루션|사용이 용이한 솔루션|UI 수준이 높고 기능이 풍부하나 설치 및 관리가 어려운 솔루션|
        |운영 가능 host 머신|1,000 nodes|1,000 nodes|10,000 nodes|
        |기술 자료|기술 자료가 매우 풍부하고 클라우드 컴퓨팅 재단(CNCF)와 협력이 많아 클라우드 친화적임|기술 자료가 풍부하고 개념과 기능이 간결한 편|MS등이 적극적으로 지원하나 기술 자료가 부족한 편|
        |라이선스 모델|아파치|아파치|아파치|
        |장점|인지도가 가장 높고 기능이 많음(타사 애드온 불필요)|도커 명령어와 도커 컴포즈를 포함,도커의 모든 기능 내장|대형 서비스를 운영 중인 회사에서 많이 채택되었고 안정성 검증|
        |단점|쿠버네티스의 구성과 개념에 대한 이해 필요|타 오케스트레이션 툴에 비해 기능이 단순, 세부적인 설정 어려움|너무 다양한 응용프로그램의 연동으로 인하여 복잡해질 수 있음(설치/관리 어려움)|
        |선택|대형 프로젝트일 경우, 세밀하고 다양한 설정 기능이 필요한 경우|중소형 프로젝트일 경우, 관리 할 노드가 적고 많은 기능이 필요하지 않을 경우|대형 프로젝트일 경우, 검증된 오케스트레이션 툴을 찾고 있는 경우 
